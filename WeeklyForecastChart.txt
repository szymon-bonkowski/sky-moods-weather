package com.example.modernweather.ui.components

import androidx.annotation.DrawableRes
import androidx.compose.animation.core.Animatable
import androidx.compose.animation.core.tween
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.runtime.Composable
import androidx.compose.runtime.LaunchedEffect
import androidx.compose.runtime.remember
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.*
import androidx.compose.ui.graphics.drawscope.DrawScope
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.drawscope.translate
import androidx.compose.ui.graphics.painter.Painter
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.TextMeasurer
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.drawText
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.rememberTextMeasurer
import androidx.compose.ui.unit.Density
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import com.example.modernweather.R
import com.example.modernweather.data.models.DailyForecast
import com.example.modernweather.data.models.TemperatureUnit
import com.example.modernweather.data.models.WeatherCondition
import com.example.modernweather.ui.screens.toFahrenheit
import com.example.modernweather.ui.theme.*
import java.time.LocalDate
import java.time.format.TextStyle as JavaTextStyle
import java.util.Locale
import kotlin.math.abs

// Data structure to hold all positioning info for a single day's forecast
private data class ForecastPoint(
    val index: Int,
    val date: LocalDate,
    val highTemp: Int,
    val lowTemp: Int,
    val condition: WeatherCondition,
    val xPosition: Float = 0f,
    val highYRaw: Float = 0f,
    val lowYRaw: Float = 0f,
    // Adjusted positions to avoid overlap
    var highYPosition: Float = 0f,
    var lowYPosition: Float = 0f,
    // Elements regions
    var highIconRegion: Region = Region(0f, 0f, 0f, 0f),
    var lowIconRegion: Region = Region(0f, 0f, 0f, 0f),
    var highTempRegion: Region = Region(0f, 0f, 0f, 0f),
    var lowTempRegion: Region = Region(0f, 0f, 0f, 0f),
    var dayLabelRegion: Region = Region(0f, 0f, 0f, 0f)
)

// Region to track space occupied by chart elements
private data class Region(
    val left: Float,
    val top: Float,
    val right: Float,
    val bottom: Float
)

@Composable
fun WeeklyForecastChart(
    modifier: Modifier = Modifier,
    dailyForecasts: List<DailyForecast>,
    unit: TemperatureUnit
) {
    if (dailyForecasts.isEmpty()) return

    val textMeasurer = rememberTextMeasurer()
    val density = LocalDensity.current
    val animationProgress = remember { Animatable(0f) }

    val dayPainters = dailyForecasts.map { painterResource(id = mapConditionToPng(it.conditionEnum, true)) }
    val nightPainters = dailyForecasts.map { painterResource(id = mapConditionToPng(it.conditionEnum, false)) }

    LaunchedEffect(dailyForecasts) {
        animationProgress.snapTo(0f)
        animationProgress.animateTo(1f, animationSpec = tween(durationMillis = 1500))
    }

    Canvas(modifier = modifier.fillMaxSize()) {
        // Constants for layout
        val xPadding = 24.dp.toPx()
        val yTopPadding = 15.dp.toPx()
        val yBottomPadding = 60.dp.toPx()
        val chartWidth = size.width - 2 * xPadding
        val chartHeight = size.height - yTopPadding - yBottomPadding
        val xStep = chartWidth / (dailyForecasts.size - 1).coerceAtLeast(1)
        val iconSize = 24.dp.toPx()
        val minIconSpacing = 36.dp.toPx() // Minimum vertical space between high and low icons
        val tempTextHeight = 16.sp.toPx() + 4.dp.toPx()

        // Get temperature range and calculate mappings
        val (minTemp, maxTemp) = getMinMaxTemperatures(dailyForecasts, unit)
        val tempRange = (maxTemp - minTemp).coerceAtLeast(1f)

        // Create initial forecast points based on raw temperature values
        val forecastPoints = dailyForecasts.mapIndexed { index, forecast ->
            val highTempF = toFahrenheitAware(forecast.highTemp, unit).toFloat()
            val lowTempF = toFahrenheitAware(forecast.lowTemp, unit).toFloat()

            // Calculate raw Y positions based on temperature
            val highYRaw = yTopPadding + (1f - (highTempF - minTemp) / tempRange) * chartHeight
            val lowYRaw = yTopPadding + (1f - (lowTempF - minTemp) / tempRange) * chartHeight

            ForecastPoint(
                index = index,
                date = forecast.date,
                highTemp = forecast.highTemp,
                lowTemp = forecast.lowTemp,
                condition = forecast.conditionEnum,
                xPosition = xPadding + index * xStep,
                highYRaw = highYRaw,
                lowYRaw = lowYRaw
            )
        }

        // Adjust positions to ensure minimum spacing between high and low temperature elements
        adjustForecastPositions(forecastPoints, minIconSpacing, iconSize, tempTextHeight, chartHeight, yTopPadding)

        // Calculate regions for all elements to avoid overlapping
        calculateElementRegions(forecastPoints, textMeasurer, unit, iconSize, density)

        // Draw vertical grid lines with gaps for elements
        drawGridLines(forecastPoints, yTopPadding, size.height - yBottomPadding)

        // Draw the temperature lines
        drawTemperatureLines(forecastPoints, AccentYellow, AccentBlue, animationProgress.value, iconSize)

        // Draw day labels and temperatures
        drawLabels(forecastPoints, textMeasurer, unit, size)

        // Draw weather icons
        forecastPoints.forEachIndexed { index, point ->
            drawWeatherIcon(dayPainters[index], point.xPosition, point.highYPosition, iconSize, animationProgress.value)
            drawWeatherIcon(nightPainters[index], point.xPosition, point.lowYPosition, iconSize, animationProgress.value)
        }
    }
}

private fun adjustForecastPositions(
    points: List<ForecastPoint>,
    minSpacing: Float,
    iconSize: Float,
    textHeight: Float,
    chartHeight: Float,
    topPadding: Float
) {
    // Initial pass: set positions to raw calculated positions
    points.forEach { point ->
        point.highYPosition = point.highYRaw
        point.lowYPosition = point.lowYRaw
    }

    // Second pass: ensure minimum spacing between high and low points
    points.forEach { point ->
        val currentSpacing = abs(point.lowYPosition - point.highYPosition)

        // If spacing is too small, adjust both high and low positions
        if (currentSpacing < minSpacing) {
            val adjustment = (minSpacing - currentSpacing) / 2

            // Move high point up and low point down
            point.highYPosition -= adjustment
            point.lowYPosition += adjustment

            // Ensure we don't go out of bounds
            if (point.highYPosition < topPadding + iconSize/2) {
                val highOverflow = topPadding + iconSize/2 - point.highYPosition
                point.highYPosition = topPadding + iconSize/2
                point.lowYPosition += highOverflow
            }

            if (point.lowYPosition > topPadding + chartHeight - iconSize/2) {
                val lowOverflow = point.lowYPosition - (topPadding + chartHeight - iconSize/2)
                point.lowYPosition = topPadding + chartHeight - iconSize/2
                point.highYPosition -= lowOverflow
                // Re-check high position
                point.highYPosition = point.highYPosition.coerceAtLeast(topPadding + iconSize/2)
            }
        }
    }

    // Third pass: ensure text for temperatures doesn't overlap
    points.forEach { point ->
        val highTextBottom = point.highYPosition - iconSize/2 - textHeight

        // If high temp text would overlap with low temp, adjust further
        if (highTextBottom < topPadding) {
            val adjustment = topPadding - highTextBottom
            point.highYPosition += adjustment
            point.lowYPosition = (point.lowYPosition + adjustment).coerceAtMost(topPadding + chartHeight - iconSize/2)
        }
    }
}

private fun calculateElementRegions(
    points: List<ForecastPoint>,
    textMeasurer: TextMeasurer,
    unit: TemperatureUnit,
    iconSize: Float,
    density: Density
) {
    with(density) {
        points.forEach { point ->
            // Icon regions
            val halfIconSize = iconSize / 2
            point.highIconRegion = Region(
                point.xPosition - halfIconSize,
                point.highYPosition - halfIconSize,
                point.xPosition + halfIconSize,
                point.highYPosition + halfIconSize
            )

            point.lowIconRegion = Region(
                point.xPosition - halfIconSize,
                point.lowYPosition - halfIconSize,
                point.xPosition + halfIconSize,
                point.lowYPosition + halfIconSize
            )

            // Temperature text regions
            val highTempText = toFahrenheitAware(point.highTemp, unit).toString() + "°"
            val highTempLayout = textMeasurer.measure(highTempText, style = TextStyle(fontSize = 16.sp))

            point.highTempRegion = Region(
                point.xPosition - highTempLayout.size.width/2,
                point.highYPosition - halfIconSize - highTempLayout.size.height - 4.dp.toPx(),
                point.xPosition + highTempLayout.size.width/2,
                point.highYPosition - halfIconSize - 4.dp.toPx()
            )

            val lowTempText = toFahrenheitAware(point.lowTemp, unit).toString() + "°"
            val lowTempLayout = textMeasurer.measure(lowTempText, style = TextStyle(fontSize = 16.sp))

            point.lowTempRegion = Region(
                point.xPosition - lowTempLayout.size.width/2,
                point.lowYPosition + halfIconSize + 4.dp.toPx(),
                point.xPosition + lowTempLayout.size.width/2,
                point.lowYPosition + halfIconSize + lowTempLayout.size.height + 4.dp.toPx()
            )
        }
    }
}

private fun DrawScope.drawWeatherIcon(
    painter: Painter,
    x: Float,
    y: Float,
    iconSize: Float,
    alpha: Float
) {
    val offset = Offset(x - iconSize / 2, y - iconSize / 2)
    translate(offset.x, offset.y) {
        with(painter) {
            draw(size = Size(iconSize, iconSize), alpha = alpha)
        }
    }
}

private fun DrawScope.drawTemperatureLines(
    points: List<ForecastPoint>,
    highColor: Color,
    lowColor: Color,
    progress: Float,
    iconSize: Float
) {
    val gapRadius = iconSize / 2 + 4.dp.toPx() // Add a small padding for visual gap

    // Draw high temperature line
    for (i in 0 until points.size - 1) {
        drawCenteredLineSegment(
            startPoint = points[i],
            endPoint = points[i+1],
            isHighTemp = true,
            color = highColor,
            progress = progress,
            gapRadius = gapRadius
        )
    }

    // Draw low temperature line
    for (i in 0 until points.size - 1) {
        drawCenteredLineSegment(
            startPoint = points[i],
            endPoint = points[i+1],
            isHighTemp = false,
            color = lowColor,
            progress = progress,
            gapRadius = gapRadius
        )
    }
}

private fun DrawScope.drawCenteredLineSegment(
    startPoint: ForecastPoint,
    endPoint: ForecastPoint,
    isHighTemp: Boolean,
    color: Color,
    progress: Float,
    gapRadius: Float
) {
    // Get the Y position for this temperature type (high or low)
    val startY = if (isHighTemp) startPoint.highYPosition else startPoint.lowYPosition
    val endY = if (isHighTemp) endPoint.highYPosition else endPoint.lowYPosition

    // Calculate horizontal gap only
    val startX = startPoint.xPosition
    val endX = endPoint.xPosition

    // Determine which direction we're drawing (left to right or right to left)
    val goingRight = startX < endX

    // Apply horizontal gaps only
    val adjustedStartX = if (goingRight) startX + gapRadius else startX - gapRadius
    val adjustedEndX = if (goingRight) endX - gapRadius else endX + gapRadius

    // Check if there's enough horizontal space to draw the line
    if ((goingRight && adjustedStartX >= adjustedEndX) ||
        (!goingRight && adjustedStartX <= adjustedEndX)) {
        return
    }

    // Create the path with the correct y positions
    val path = Path().apply {
        moveTo(adjustedStartX, startY)


        // Use a cubic bezier curve with horizontal control points
        // that are positioned to create a smooth line
        val midX = (adjustedStartX + adjustedEndX) / 2

        // Key change: ensure control points maintain exact Y positions
        // at the connection points with icons
        cubicTo(
            x1 = midX, y1 = startY,
            x2 = midX, y2 = endY,
            x3 = adjustedEndX, y3 = endY
        )
    }

    // Apply animation progress
    val segmentProgress = progress.coerceIn(0f, 1f)
    val animatedPath = Path()
    PathMeasure().apply {
        setPath(path, false)
        getSegment(0f, length * segmentProgress, animatedPath, true)
    }

    drawPath(
        path = animatedPath,
        color = color,
        style = Stroke(width = 2.5.dp.toPx(), cap = StrokeCap.Round)
    )
}

private fun DrawScope.drawGridLines(
    points: List<ForecastPoint>,
    yTop: Float,
    yBottom: Float
) {
    val lineAlpha = 0.3f
    val lineWidth = 1.dp.toPx()
    val gapBuffer = 3.dp.toPx() // Extra space around elements for cleaner look

    points.forEach { point ->
        val obstacles = listOf(
            point.highTempRegion,
            point.highIconRegion,
            point.lowIconRegion,
            point.lowTempRegion
        )

        // Sort obstacles by vertical position
        val sortedObstacles = obstacles.sortedBy { it.top }
        var currentY = yTop

        // Draw line segments between obstacles
        for (obstacle in sortedObstacles) {
            if (obstacle.top - gapBuffer > currentY) {
                drawLine(
                    color = OnSurfaceVariant.copy(alpha = lineAlpha),
                    start = Offset(point.xPosition, currentY),
                    end = Offset(point.xPosition, obstacle.top - gapBuffer),
                    strokeWidth = lineWidth
                )
            }
            currentY = obstacle.bottom + gapBuffer
        }

        // Draw final segment if needed
        if (yBottom > currentY) {
            drawLine(
                color = OnSurfaceVariant.copy(alpha = lineAlpha),
                start = Offset(point.xPosition, currentY),
                end = Offset(point.xPosition, yBottom),
                strokeWidth = lineWidth
            )
        }
    }
}

private fun DrawScope.drawLabels(
    points: List<ForecastPoint>,
    textMeasurer: TextMeasurer,
    unit: TemperatureUnit,
    size: Size
) {
    val onSurfaceColor = Color.White
    val onSurfaceVariantColor = OnSurfaceVariant
    val isTodayColor = Color(0xFFFF6F6F)

    points.forEach { point ->
        // Draw high temperature
        val highTempText = toFahrenheitAware(point.highTemp, unit).toString()
        val highTempStyle = TextStyle(
            fontSize = 16.sp,
            fontWeight = FontWeight.SemiBold,
            color = onSurfaceColor
        )
        val highTempLayout = textMeasurer.measure(highTempText, style = highTempStyle)
        val degreeSymbolLayout = textMeasurer.measure("°", style = highTempStyle)

        val highTempX = point.xPosition - highTempLayout.size.width / 2
        val highTempY = point.highYPosition - highTempLayout.size.height - 18.dp.toPx()
        drawText(highTempLayout, topLeft = Offset(highTempX, highTempY))
        drawText(degreeSymbolLayout, topLeft = Offset(highTempX + highTempLayout.size.width, highTempY))

        // Draw low temperature
        val lowTempText = toFahrenheitAware(point.lowTemp, unit).toString()
        val lowTempStyle = highTempStyle.copy(color = onSurfaceColor)
        val lowTempLayout = textMeasurer.measure(lowTempText, style = lowTempStyle)
        val lowDegreeLayout = textMeasurer.measure("°", style = lowTempStyle)

        val lowTempX = point.xPosition - lowTempLayout.size.width / 2
        val lowTempY = point.lowYPosition + 15.dp.toPx()
        drawText(lowTempLayout, topLeft = Offset(lowTempX, lowTempY))
        drawText(lowDegreeLayout, topLeft = Offset(lowTempX + lowTempLayout.size.width, lowTempY))

        // Draw day of week
        var dayOfWeekText = point.date.dayOfWeek.getDisplayName(
            JavaTextStyle.SHORT,
            Locale.forLanguageTag("pl")
        ).replaceFirstChar { it.titlecase(Locale.forLanguageTag("pl")) }

        if (dayOfWeekText == "Niedz.") dayOfWeekText = "Ndz."
        val dayOfWeekTextNoDot = dayOfWeekText.removeSuffix(".")
        val dot = if (dayOfWeekText.endsWith(".")) "." else ""
        val isToday = point.date == LocalDate.now()

        val dayColor = if (isToday) isTodayColor else onSurfaceVariantColor
        val dayStyle = TextStyle(color = dayColor, fontSize = 14.sp, fontWeight = FontWeight.Medium)
        val dayLayout = textMeasurer.measure(dayOfWeekTextNoDot, style = dayStyle)
        val dotLayout = if (dot.isNotEmpty()) textMeasurer.measure(dot, style = dayStyle) else null

        val dayX = point.xPosition - dayLayout.size.width / 2
        val dayY = size.height - 50.dp.toPx()
        drawText(dayLayout, topLeft = Offset(dayX, dayY))

        if (dotLayout != null) {
            drawText(dotLayout, topLeft = Offset(dayX + dayLayout.size.width, dayY))
        }

        // Draw day of month
        val dayOfMonthText = point.date.dayOfMonth.toString()
        val dayOfMonthLayout = textMeasurer.measure(
            dayOfMonthText,
            style = TextStyle(color = onSurfaceVariantColor, fontSize = 14.sp)
        )

        drawText(
            dayOfMonthLayout,
            topLeft = Offset(point.xPosition - dayOfMonthLayout.size.width / 2, size.height - 32.dp.toPx())
        )
    }
}

@DrawableRes
private fun mapConditionToPng(condition: WeatherCondition, isDay: Boolean): Int {
    return if (isDay) {
        when (condition) {
            WeatherCondition.DAY_SUNNY -> R.drawable.day
            WeatherCondition.DAY_PARTLY_CLOUDY -> R.drawable.cloudy_day
            WeatherCondition.DAY_CLOUDY -> R.drawable.cloudy
            WeatherCondition.DAY_RAIN_LIGHT -> R.drawable.light_rain_day
            WeatherCondition.DAY_RAIN_MEDIUM -> R.drawable.medium_rain_day
            WeatherCondition.DAY_RAIN_HEAVY -> R.drawable.heavy_rain
            WeatherCondition.DAY_SNOW -> R.drawable.snow_day
            WeatherCondition.DAY_FOG -> R.drawable.fog_day
            WeatherCondition.DAY_FOG_CLOUDY -> R.drawable.fog_cloudy
            WeatherCondition.DAY_THUNDERSTORM -> R.drawable.thunderstorm_day
            WeatherCondition.DAY_THUNDERSTORM_HEAVY -> R.drawable.thunderstorm_heavy_rain
            WeatherCondition.DAY_THUNDERSTORM_RAIN_LIGHT -> R.drawable.thunderstorm_light_rain_day
            WeatherCondition.DAY_THUNDERSTORM_RAIN_MEDIUM -> R.drawable.thunderstorm_medium_rain_day
            WeatherCondition.DAY_WIND -> R.drawable.wind_day
            WeatherCondition.DAY_WIND_CLOUDY -> R.drawable.wind_cloudy
            else -> R.drawable.cloudy
        }
    } else {
        when (condition) {
            WeatherCondition.NIGHT_CLEAR -> R.drawable.night
            WeatherCondition.NIGHT_PARTLY_CLOUDY -> R.drawable.cloudy_night
            WeatherCondition.NIGHT_CLOUDY -> R.drawable.cloudy_night
            WeatherCondition.NIGHT_RAIN_LIGHT -> R.drawable.light_rain_night
            WeatherCondition.NIGHT_RAIN_MEDIUM -> R.drawable.medium_rain_night
            WeatherCondition.NIGHT_SNOW -> R.drawable.snow_night
            WeatherCondition.NIGHT_FOG -> R.drawable.fog_night
            WeatherCondition.NIGHT_THUNDERSTORM -> R.drawable.thunderstorm_night
            WeatherCondition.NIGHT_THUNDERSTORM_RAIN_LIGHT -> R.drawable.thunderstorm_light_rain_night
            WeatherCondition.NIGHT_THUNDERSTORM_MEDIUM_RAIN -> R.drawable.thunderstorm_medium_rain_night
            WeatherCondition.NIGHT_WIND -> R.drawable.wind_night
            else -> R.drawable.cloudy_night
        }
    }
}

private fun getMinMaxTemperatures(forecasts: List<DailyForecast>, unit: TemperatureUnit): Pair<Float, Float> {
    if (forecasts.isEmpty()) return 0f to 0f
    val allTemps = forecasts.flatMap {
        listOf(toFahrenheitAware(it.highTemp, unit).toFloat(), toFahrenheitAware(it.lowTemp, unit).toFloat())
    }
    val min = allTemps.minOrNull() ?: 0f
    val max = allTemps.maxOrNull() ?: 0f
    return (min - 5f) to (max + 5f)
}

private fun toFahrenheitAware(celsius: Int, unit: TemperatureUnit): Int =
    if (unit == TemperatureUnit.CELSIUS) celsius else toFahrenheit(celsius)